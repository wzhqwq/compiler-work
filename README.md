# 编译原理实验项目

## 限制

本项目仅限山东大学软件学院高老师的编译原理课，其他老师出的实验可能并不一样。本项目基于PL/0的部分语法开发，并没有支持`if...else`语句，支持的全部产生式见[所有产生式](https://github.com/wzhqwq/compiler-work/blob/master/%E6%89%80%E6%9C%89%E4%BA%A7%E7%94%9F%E5%BC%8F.txt)。

## 设计方案

词法分析实验利用DFA完成对词法的匹配，然后利用字典树为关键字和运算符附上`SymbolId`，最终输出`TerminalSymbol`数组以及两个没用的NUM数组和ID数组（实验要求）。

语法制导翻译实验利用LL1预测器进行语法分析，并结合回填技术完成一次扫描翻译。LL1预测器由一套类似yacc的模块构建，模块接收一组符合LL1文法的产生式（`Production`），产生式的构建依赖提前定义好的一套抽象终结符和非终结符（`LiteralTerminalSymbol`和`LiteralNonTerminalSymbol`）。抽象非终结符类允许覆盖匹配失败时返回错误信息的方法`getMismatchMessage`，对于带有综合属性的非终结符，允许覆盖返回继承`NonTerminalSymbol`的类实例的方法`toNonTerminalSymbol`。产生式可以附加一套语法规则，语法规则在预测器规约过程被调用，语法规则函数可以得到产生式左侧、右侧的符号对象，从而操作产生是左侧非终结符的综合属性，还能操作`ParsingEnv`中的符号表、代码表和标识符暂存区，在预测的同时完成翻译过程。

解释器实验需要完成一个仅通过栈分配空间、利用栈完成计算的笨蛋虚拟机，呃……好像没什么好介绍的，整个包里也就四个类，也就封装了下，没用什么奇怪的东西。

## 项目结构

```plain
src
├── org
│   └── wzhqwq
│       ├── enums （存放所有的枚举类型以及一个无处安放的Symbol类）
│       ├── exception （存放所有的处理异常，写得不是很完善）
│       ├── lexical （文法分析）
│       │   ├── dfa （所有基于DFA的匹配器）
│       │   ├── symbol （所有的终结符类）
│       │   └── trie （所有基于字典树的匹配器，会返回对应的终结符类）
│       ├── syntax （语法制导翻译）
│       │   ├── parser （所有与语法制导翻译过程相关的类）
│       │   ├── production （产生式及其相关的类）
│       │   │   └── literal （支持抽象符号的类）
│       │   └── symbol （所有的非终结符类）
│       ├── util （里面只有一个代码读入模拟类，里面还提供了有bug的错误打印功能）
│       └── vm （解释器部分，不复杂）
└── resources （可以存点待读入的代码，但这功能我没写）
```

## 怎么跑

运行后，输入PL/0代码，然后敲一个$表示代码结束，如果没有语法错误，程序会开始执行，输入读入的数据，程序运行完成会自动退出。
